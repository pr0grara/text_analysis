'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "5.1.0-beta.1";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const MultiLanguageBatchInput = {
    type: {
        name: "Composite",
        className: "MultiLanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextDocumentInput" }
                    }
                }
            }
        }
    }
};
const TextDocumentInput = {
    type: {
        name: "Composite",
        className: "TextDocumentInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EntitiesResult = {
    type: {
        name: "Composite",
        className: "EntitiesResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DocumentEntities" }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "DocumentError" } }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentEntities = {
    type: {
        name: "Composite",
        className: "DocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Entity" } }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextAnalyticsWarning" }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const Entity = {
    type: {
        name: "Composite",
        className: "Entity",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subCategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TextAnalyticsWarning = {
    type: {
        name: "Composite",
        className: "TextAnalyticsWarning",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TextDocumentStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentStatistics",
        modelProperties: {
            characterCount: {
                serializedName: "charactersCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentError = {
    type: {
        name: "Composite",
        className: "DocumentError",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const TextAnalyticsError = {
    type: {
        name: "Composite",
        className: "TextAnalyticsError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextAnalyticsError" }
                    }
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const TextDocumentBatchStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentBatchStatistics",
        modelProperties: {
            documentCount: {
                serializedName: "documentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            validDocumentCount: {
                serializedName: "validDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            erroneousDocumentCount: {
                serializedName: "erroneousDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const PiiEntitiesResult = {
    type: {
        name: "Composite",
        className: "PiiEntitiesResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "PiiDocumentEntities" }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "DocumentError" } }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PiiDocumentEntities = {
    type: {
        name: "Composite",
        className: "PiiDocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Entity" } }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextAnalyticsWarning" }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            },
            redactedText: {
                serializedName: "redactedText",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EntityLinkingResult = {
    type: {
        name: "Composite",
        className: "EntityLinkingResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DocumentLinkedEntities" }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "DocumentError" } }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLinkedEntities = {
    type: {
        name: "Composite",
        className: "DocumentLinkedEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "LinkedEntity" } }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextAnalyticsWarning" }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const LinkedEntity = {
    type: {
        name: "Composite",
        className: "LinkedEntity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            matches: {
                serializedName: "matches",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "Match" } }
                }
            },
            language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceEntityId: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            bingEntitySearchApiId: {
                serializedName: "bingId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Match = {
    type: {
        name: "Composite",
        className: "Match",
        modelProperties: {
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const KeyPhraseResult = {
    type: {
        name: "Composite",
        className: "KeyPhraseResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DocumentKeyPhrases" }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "DocumentError" } }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentKeyPhrases = {
    type: {
        name: "Composite",
        className: "DocumentKeyPhrases",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyPhrases: {
                serializedName: "keyPhrases",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "String" } }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextAnalyticsWarning" }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const LanguageBatchInput = {
    type: {
        name: "Composite",
        className: "LanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DetectLanguageInput" }
                    }
                }
            }
        }
    }
};
const DetectLanguageInput = {
    type: {
        name: "Composite",
        className: "DetectLanguageInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            countryHint: {
                serializedName: "countryHint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageResult = {
    type: {
        name: "Composite",
        className: "LanguageResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DocumentLanguage" }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "DocumentError" } }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLanguage = {
    type: {
        name: "Composite",
        className: "DocumentLanguage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            detectedLanguage: {
                serializedName: "detectedLanguage",
                type: {
                    name: "Composite",
                    className: "DetectedLanguage"
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextAnalyticsWarning" }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const DetectedLanguage = {
    type: {
        name: "Composite",
        className: "DetectedLanguage",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            iso6391Name: {
                serializedName: "iso6391Name",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentimentResponse = {
    type: {
        name: "Composite",
        className: "SentimentResponse",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "DocumentSentiment" }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "DocumentError" } }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentSentiment = {
    type: {
        name: "Composite",
        className: "DocumentSentiment",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative", "mixed"]
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            sentenceSentiments: {
                serializedName: "sentences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "SentenceSentiment" }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "TextAnalyticsWarning" }
                    }
                }
            }
        }
    }
};
const SentimentConfidenceScores = {
    type: {
        name: "Composite",
        className: "SentimentConfidenceScores",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            neutral: {
                serializedName: "neutral",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentenceSentiment = {
    type: {
        name: "Composite",
        className: "SentenceSentiment",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            aspects: {
                serializedName: "aspects",
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "SentenceAspect" } }
                }
            },
            opinions: {
                serializedName: "opinions",
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "SentenceOpinion" } }
                }
            }
        }
    }
};
const SentenceAspect = {
    type: {
        name: "Composite",
        className: "SentenceAspect",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "AspectConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "AspectRelation" } }
                }
            }
        }
    }
};
const AspectConfidenceScoreLabel = {
    type: {
        name: "Composite",
        className: "AspectConfidenceScoreLabel",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AspectRelation = {
    type: {
        name: "Composite",
        className: "AspectRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["opinion", "aspect"]
                }
            },
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentenceOpinion = {
    type: {
        name: "Composite",
        className: "SentenceOpinion",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "AspectConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            isNegated: {
                serializedName: "isNegated",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MultiLanguageBatchInput: MultiLanguageBatchInput,
    TextDocumentInput: TextDocumentInput,
    EntitiesResult: EntitiesResult,
    DocumentEntities: DocumentEntities,
    Entity: Entity,
    TextAnalyticsWarning: TextAnalyticsWarning,
    TextDocumentStatistics: TextDocumentStatistics,
    DocumentError: DocumentError,
    TextAnalyticsError: TextAnalyticsError,
    InnerError: InnerError,
    TextDocumentBatchStatistics: TextDocumentBatchStatistics,
    ErrorResponse: ErrorResponse,
    PiiEntitiesResult: PiiEntitiesResult,
    PiiDocumentEntities: PiiDocumentEntities,
    EntityLinkingResult: EntityLinkingResult,
    DocumentLinkedEntities: DocumentLinkedEntities,
    LinkedEntity: LinkedEntity,
    Match: Match,
    KeyPhraseResult: KeyPhraseResult,
    DocumentKeyPhrases: DocumentKeyPhrases,
    LanguageBatchInput: LanguageBatchInput,
    DetectLanguageInput: DetectLanguageInput,
    LanguageResult: LanguageResult,
    DocumentLanguage: DocumentLanguage,
    DetectedLanguage: DetectedLanguage,
    SentimentResponse: SentimentResponse,
    DocumentSentiment: DocumentSentiment,
    SentimentConfidenceScores: SentimentConfidenceScores,
    SentenceSentiment: SentenceSentiment,
    SentenceAspect: SentenceAspect,
    AspectConfidenceScoreLabel: AspectConfidenceScoreLabel,
    AspectRelation: AspectRelation,
    SentenceOpinion: SentenceOpinion
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const input = {
    parameterPath: "input",
    mapper: MultiLanguageBatchInput
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const modelVersion = {
    parameterPath: ["options", "modelVersion"],
    mapper: {
        serializedName: "model-version",
        type: {
            name: "String"
        }
    }
};
const includeStatistics = {
    parameterPath: ["options", "includeStatistics"],
    mapper: {
        serializedName: "includeStatistics",
        type: {
            name: "Boolean"
        }
    }
};
const stringIndexType = {
    parameterPath: ["options", "stringIndexType"],
    mapper: {
        defaultValue: "TextElements_v8",
        serializedName: "stringIndexType",
        type: {
            name: "String"
        }
    }
};
const domain = {
    parameterPath: ["options", "domain"],
    mapper: {
        serializedName: "domain",
        type: {
            name: "String"
        }
    }
};
const input1 = {
    parameterPath: "input",
    mapper: LanguageBatchInput
};
const opinionMining = {
    parameterPath: ["options", "opinionMining"],
    mapper: {
        serializedName: "opinionMining",
        type: {
            name: "Boolean"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "@azure/ai-text-analytics";
const packageVersion = "5.1.0-beta.1";
class GeneratedClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri =
            options.endpoint || "{Endpoint}/text/analytics/v3.1-preview.2";
        // Parameter assignments
        this.endpoint = endpoint;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * The API returns a list of general named entities in a given document. For the list of supported
     * entity types, check <a href="https://aka.ms/taner">Supported Entity Types in Text Analytics API</a>.
     * See the <a href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list
     * of enabled languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionGeneral(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, entitiesRecognitionGeneralOperationSpec);
    }
    /**
     * The API returns a list of entities with personal information (\"SSN\", \"Bank Account\" etc) in the
     * document. For the list of supported entity types, check <a href="https://aka.ms/tanerpii">Supported
     * Entity Types in Text Analytics API</a>. See the <a href="https://aka.ms/talangs">Supported languages
     * in Text Analytics API</a> for the list of enabled languages.
     *
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionPii(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, entitiesRecognitionPiiOperationSpec);
    }
    /**
     * The API returns a list of recognized entities with links to a well-known knowledge base. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesLinking(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, entitiesLinkingOperationSpec);
    }
    /**
     * The API returns a list of strings denoting the key phrases in the input text. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    keyPhrases(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, keyPhrasesOperationSpec);
    }
    /**
     * The API returns the detected language and a numeric score between 0 and 1. Scores close to 1
     * indicate 100% certainty that the identified language is true. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze for language endpoint.
     * @param options The options parameters.
     */
    languages(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, languagesOperationSpec);
    }
    /**
     * The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple
     * levels of granularity, start from the a document level, down to sentence and key terms (aspects) and
     * opinions.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    sentiment(input, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ input, options: operationOptions }, sentimentOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const entitiesRecognitionGeneralOperationSpec = {
    path: "/entities/recognition/general",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntitiesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        modelVersion,
        includeStatistics,
        stringIndexType
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const entitiesRecognitionPiiOperationSpec = {
    path: "/entities/recognition/pii",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PiiEntitiesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        modelVersion,
        includeStatistics,
        stringIndexType,
        domain
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const entitiesLinkingOperationSpec = {
    path: "/entities/linking",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntityLinkingResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        modelVersion,
        includeStatistics,
        stringIndexType
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const keyPhrasesOperationSpec = {
    path: "/keyPhrases",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: KeyPhraseResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [modelVersion, includeStatistics],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const languagesOperationSpec = {
    path: "/languages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LanguageResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input1,
    queryParameters: [modelVersion, includeStatistics],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const sentimentOperationSpec = {
    path: "/sentiment",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SentimentResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        modelVersion,
        includeStatistics,
        stringIndexType,
        opinionMining
    ],
    urlParameters: [endpoint],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * The @azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("ai-text-analytics");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper function for converting nested service error into
 * the unified TextAnalyticsError
 */
function intoTextAnalyticsError(errorModel) {
    // Return the deepest error. This will always be at most
    // one level for TextAnalytics
    if (errorModel.innererror !== undefined) {
        return intoTextAnalyticsError(errorModel.innererror);
    }
    return {
        code: errorModel.code,
        message: errorModel.message,
        target: errorModel.target
    };
}
function makeTextAnalyticsSuccessResult(id, warnings, statistics) {
    return {
        id,
        statistics,
        warnings
    };
}
function makeTextAnalyticsErrorResult(id, error) {
    return {
        id,
        error: intoTextAnalyticsError(error)
    };
}

// Copyright (c) Microsoft Corporation.
function makeDetectLanguageResult(id, detectedLanguage, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { primaryLanguage: detectedLanguage });
}
function makeDetectLanguageErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * @ignore
 * @param sortedArray An array of entries sorted by `id`
 * @param unsortedArray An array of entries that contain `id` but are not sorted
 */
function sortResponseIdObjects(sortedArray, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedArray.length) {
        const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    return sortedArray.map((item) => unsortedMap.get(item.id));
}
function findOpinionIndex(pointer) {
    const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/opinions\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        const opinionIndex = {
            document: parseInt(res[1]),
            sentence: parseInt(res[2]),
            opinion: parseInt(res[3])
        };
        return opinionIndex;
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid opinion pointer`);
    }
}
function addStrEncodingParam(options) {
    return Object.assign(Object.assign({}, options), { stringIndexType: "Utf16CodeUnit" });
}

// Copyright (c) Microsoft Corporation.
function makeDetectLanguageResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeDetectLanguageResult(document.id, document.detectedLanguage, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeDetectLanguageErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeCategorizedEntitiesResult(id, entities, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeCategorizedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeCategorizedEntitiesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizeCategorizedEntitiesResult(document.id, document.entities, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeRecognizeCategorizedEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeAnalyzeSentimentResult(document) {
    const { id, sentiment, confidenceScores, sentenceSentiments: sentences, warnings, statistics } = document;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { sentiment,
        confidenceScores, sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, document)) });
}
function makeAnalyzeSentimentErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}
/**
 * Converts a sentence sentiment object returned by the service to another that
 * is user-friendly.
 *
 * @param sentence - The sentence sentiment object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly sentence sentiment object.
 */
function convertGeneratedSentenceSentiment(sentence, document) {
    return {
        confidenceScores: sentence.confidenceScores,
        sentiment: sentence.sentiment,
        text: sentence.text,
        length: sentence.length,
        offset: sentence.offset,
        minedOpinions: sentence.aspects
            ? sentence.aspects.map((aspect) => ({
                aspect: {
                    confidenceScores: aspect.confidenceScores,
                    sentiment: aspect.sentiment,
                    text: aspect.text,
                    offset: aspect.offset,
                    length: aspect.length
                },
                opinions: aspect.relations
                    .filter((relation) => relation.relationType === "opinion")
                    .map((relation) => convertAspectRelationToOpinionSentiment(relation, document))
            }))
            : []
    };
}
/**
 * Converts an aspect relation object returned by the service to an opinion
 * sentiment object where JSON pointers in the former are realized in the
 * latter.
 *
 * @param aspectRelation - The aspect relation object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly opinion sentiment object.
 */
function convertAspectRelationToOpinionSentiment(aspectRelation, document) {
    var _a, _b;
    const opinionPtr = aspectRelation.ref;
    const opinionIndex = findOpinionIndex(opinionPtr);
    const opinion = (_b = (_a = document.sentenceSentiments) === null || _a === void 0 ? void 0 : _a[opinionIndex.sentence].opinions) === null || _b === void 0 ? void 0 : _b[opinionIndex.opinion];
    if (opinion !== undefined) {
        return opinion;
    }
    else {
        throw new Error(`Pointer "${opinionPtr}" is not a valid opinion pointer`);
    }
}

// Copyright (c) Microsoft Corporation.
function makeAnalyzeSentimentResultArray(input, response) {
    const { documents, errors, modelVersion, statistics } = response;
    const unsortedResult = documents
        .map((document) => {
        return makeAnalyzeSentimentResult(document);
    })
        .concat(errors.map((error) => {
        return makeAnalyzeSentimentErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeExtractKeyPhrasesResult(id, keyPhrases, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { keyPhrases });
}
function makeExtractKeyPhrasesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeExtractKeyPhrasesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeExtractKeyPhrasesResult(document.id, document.keyPhrases, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeExtractKeyPhrasesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizePiiEntitiesResult(document) {
    const { id, entities, warnings, statistics, redactedText } = document;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities,
        redactedText });
}
function makeRecognizePiiEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizePiiEntitiesResultArray(input, response) {
    const { documents, errors, statistics, modelVersion } = response;
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizePiiEntitiesResult(document);
    })
        .concat(errors.map((error) => {
        return makeRecognizePiiEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeLinkedEntitiesResult(id, entities, warnings, statistics) {
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeLinkedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
function makeRecognizeLinkedEntitiesResultArray(input, documents, errors, modelVersion, statistics) {
    const unsortedResult = documents
        .map((document) => {
        return makeRecognizeLinkedEntitiesResult(document.id, document.entities, document.warnings, document.statistics);
    })
        .concat(errors.map((error) => {
        return makeRecognizeLinkedEntitiesErrorResult(error.id, error.error);
    }));
    const result = sortResponseIdObjects(input, unsortedResult);
    return Object.assign(result, {
        statistics,
        modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @ignore
 * @param name The name of the operation being performed.
 * @param tracingOptions The options for the underlying http request.
 */
function createSpan(operationName, operationOptions) {
    const tracer = coreTracing.getTracer();
    const tracingOptions = operationOptions.tracingOptions || {};
    const spanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { kind: api.SpanKind.INTERNAL });
    const span = tracer.startSpan(`Azure.CognitiveServices.TextAnalytics.${operationName}`, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.CognitiveServices");
    let newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording()) {
        newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.CognitiveServices" }) });
    }
    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions });
    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
        span,
        updatedOptions: newOperationOptions
    };
}

// Copyright (c) Microsoft Corporation.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 */
function createTextAnalyticsAzureKeyCredentialPolicy(credential) {
    return {
        create: (nextPolicy, options) => {
            return new TextAnalyticsAzureKeyCredentialPolicy(nextPolicy, options, credential);
        }
    };
}
/**
 * A concrete implementation of an AzureKeyCredential policy
 * using the appropriate header for TextAnalytics
 */
class TextAnalyticsAzureKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, credential) {
        super(nextPolicy, options);
        this.credential = credential;
    }
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!webResource) {
                throw new Error("webResource cannot be null or undefined");
            }
            webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);
            return this._nextPolicy.sendRequest(webResource);
        });
    }
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
(function (PiiEntityDomainType) {
    /**
     * See https://aka.ms/tanerpii for more information.
     */
    PiiEntityDomainType["PROTECTED_HEALTH_INFORMATION"] = "PHI";
})(exports.PiiEntityDomainType || (exports.PiiEntityDomainType = {}));
/**
 * Client class for interacting with Azure Text Analytics.
 */
class TextAnalyticsClient {
    /**
     * Creates an instance of TextAnalyticsClient.
     *
     * Example usage:
     * ```ts
     * import { TextAnalyticsClient, AzureKeyCredential } from "@azure/ai-text-analytics";
     *
     * const client = new TextAnalyticsClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param {string} endpointUrl The URL to the TextAnalytics endpoint
     * @param {TokenCredential | KeyCredential} credential Used to authenticate requests to the service.
     * @param {TextAnalyticsClientOptions} [options] Used to configure the TextAnalytics client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = tslib.__rest(options, ["defaultCountryHint", "defaultLanguage"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createTextAnalyticsAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
            }
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(this.endpointUrl, pipeline);
    }
    detectLanguage(documents, countryHintOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const countryHint = countryHintOrOptions || this.defaultCountryHint;
                realInputs = convertToDetectLanguageInput(documents, countryHint);
                realOptions = options || {};
            }
            else {
                // Replace "none" hints with ""
                realInputs = documents.map((input) => (Object.assign(Object.assign({}, input), { countryHint: input.countryHint === "none" ? "" : input.countryHint })));
                realOptions = countryHintOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", realOptions);
            try {
                const result = yield this.client.languages({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeDetectLanguageResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeEntities(documents, languageOrOptions, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionGeneral({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeRecognizeCategorizedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                let backwardCompatibleException;
                /**
                 * This special logic handles REST exception with code
                 * InvalidDocumentBatch and is needed to maintain backward compatability
                 * with sdk v5.0.0 and earlier. In general, REST exceptions are thrown as
                 * is and include both outer and inner exception codes. However, the
                 * earlier versions were throwing an exception that included the inner
                 * code only.
                 */
                const innerCode = (_d = (_c = (_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.innererror) === null || _d === void 0 ? void 0 : _d.code;
                const innerMessage = (_h = (_g = (_f = (_e = e.response) === null || _e === void 0 ? void 0 : _e.parsedBody) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.innererror) === null || _h === void 0 ? void 0 : _h.message;
                if (innerCode === "InvalidDocumentBatch") {
                    backwardCompatibleException = new coreHttp.RestError(innerMessage, innerCode, e.statusCode);
                }
                else {
                    backwardCompatibleException = e;
                }
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: backwardCompatibleException.message
                });
                throw backwardCompatibleException;
            }
            finally {
                span.end();
            }
        });
    }
    analyzeSentiment(documents, languageOrOptions, options) {
        var _a, _b, _c;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = {
                    includeStatistics: options === null || options === void 0 ? void 0 : options.includeStatistics,
                    modelVersion: options === null || options === void 0 ? void 0 : options.modelVersion,
                    opinionMining: options === null || options === void 0 ? void 0 : options.includeOpinionMining
                };
            }
            else {
                realInputs = documents;
                realOptions = {
                    includeStatistics: (_a = languageOrOptions) === null || _a === void 0 ? void 0 : _a.includeStatistics,
                    modelVersion: (_b = languageOrOptions) === null || _b === void 0 ? void 0 : _b.modelVersion,
                    opinionMining: (_c = languageOrOptions) === null || _c === void 0 ? void 0 : _c.includeOpinionMining
                };
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", realOptions);
            try {
                const result = yield this.client.sentiment({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeAnalyzeSentimentResultArray(realInputs, result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    extractKeyPhrases(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", realOptions);
            try {
                const result = yield this.client.keyPhrases({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(finalOptions));
                return makeExtractKeyPhrasesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizePiiEntities(inputs, languageOrOptions, options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(inputs, language);
                realOptions = options || {};
                realOptions.domain = options === null || options === void 0 ? void 0 : options.domainFilter;
            }
            else {
                realInputs = inputs;
                realOptions = languageOrOptions || {};
                realOptions.domain = (_a = languageOrOptions) === null || _a === void 0 ? void 0 : _a.domainFilter;
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizePiiEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionPii({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeRecognizePiiEntitiesResultArray(realInputs, result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeLinkedEntities(documents, languageOrOptions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (!Array.isArray(documents) || documents.length === 0) {
                throw new Error("'documents' must be a non-empty array");
            }
            if (isStringArray(documents)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(documents, language);
                realOptions = options || {};
            }
            else {
                realInputs = documents;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", realOptions);
            try {
                const result = yield this.client.entitiesLinking({
                    documents: realInputs
                }, coreHttp.operationOptionsToRequestOptionsBase(addStrEncodingParam(finalOptions)));
                return makeRecognizeLinkedEntitiesResultArray(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}
function isStringArray(documents) {
    return typeof documents[0] === "string";
}
function convertToDetectLanguageInput(inputs, countryHint) {
    if (countryHint === "none") {
        countryHint = "";
    }
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text
        };
    });
}
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text
        };
    });
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.TextAnalyticsClient = TextAnalyticsClient;
//# sourceMappingURL=index.js.map
